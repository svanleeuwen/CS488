!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AABB	bbox.cpp	/^AABB::AABB(Point3D min, Point3D max) {$/;"	f	class:AABB
AABB	bbox.cpp	/^AABB::AABB(const AABB& other) {$/;"	f	class:AABB
AABB	bbox.hpp	/^    AABB() {}$/;"	f	class:AABB
AABB	bbox.hpp	/^class AABB{$/;"	c
AR	Makefile	/^AR            = ar cqs$/;"	m
B	algebra.hpp	/^  double B() const $/;"	f	class:Colour
BIHNode	bih.cpp	/^BIHNode::BIHNode(Primitive** primitives, int size, const AABB& bbox, int depth) :$/;"	f	class:BIHNode
BIHNode	bih.hpp	/^class BIHNode {$/;"	c
BIHTree	bih.cpp	/^BIHTree::BIHTree(Primitive** primitives, int size) :$/;"	f	class:BIHTree
BIHTree	bih.hpp	/^class BIHTree {$/;"	c
CAMERA_HPP	camera.hpp	2;"	d
CC	Makefile	/^CC            = gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS        = -pipe -O2 -Wall -W -D_REENTRANT -fPIE $(DEFINES)$/;"	m
CHK_DIR_EXISTS	Makefile	/^CHK_DIR_EXISTS= test -d$/;"	m
COMPRESS	Makefile	/^COMPRESS      = gzip -9f$/;"	m
COPY	Makefile	/^COPY          = cp -f$/;"	m
COPY_DIR	Makefile	/^COPY_DIR      = cp -f -R$/;"	m
COPY_FILE	Makefile	/^COPY_FILE     = cp -f$/;"	m
CS488_A4_HPP	a4.hpp	2;"	d
CS488_ALGEBRA_HPP	algebra.hpp	16;"	d
CS488_BBOX_HPP	bbox.hpp	2;"	d
CS488_BIH_HPP	bih.hpp	3;"	d
CS488_GAME_HPP	game.hpp	21;"	d
CS488_IMAGE_HPP	image.hpp	2;"	d
CS488_INTERVAL_HPP	interval.hpp	2;"	d
CS488_LIGHT_HPP	light.hpp	2;"	d
CS488_MATERIAL_HPP	material.hpp	2;"	d
CS488_MESH_HPP	mesh.hpp	2;"	d
CS488_PACKET_HPP	packet.hpp	2;"	d
CS488_POLYROOTS_HPP	polyroots.hpp	14;"	d
CS488_PRIMITIVE_HPP	primitive.hpp	2;"	d
CXX	Makefile	/^CXX           = g++$/;"	m
CXXFLAGS	Makefile	/^CXXFLAGS      = -pipe -W -Wall -g -pthread -D BIH -D PACKET -O2 -std=c++0x -Wall -W -D_REENTRANT -fPIE $(DEFINES)$/;"	m
Camera	camera.cpp	/^Camera::Camera(const Camera& other) {$/;"	f	class:Camera
Camera	camera.cpp	/^Camera::Camera(int width, int height, const Point3D& eye, const Vector3D& view, const Vector3D& up, double fov):$/;"	f	class:Camera
Camera	camera.hpp	/^class Camera {$/;"	c
CameraPacket	packet.cpp	/^CameraPacket::CameraPacket() {}$/;"	f	class:CameraPacket
CameraPacket	packet.cpp	/^CameraPacket::CameraPacket(const CameraPacket& other) : $/;"	f	class:CameraPacket
CameraPacket	packet.cpp	/^CameraPacket::CameraPacket(int width, int height, int i, int j, QImage* img, Tracer* tracer) :$/;"	f	class:CameraPacket
CameraPacket	packet.hpp	/^class CameraPacket : public Packet{$/;"	c
ChildList	scene.hpp	/^    typedef std::vector<SceneNode*> ChildList;$/;"	t	class:SceneNode
Colour	algebra.hpp	/^  Colour() : r_(0.0), g_(0.0), b_(0.0) {}$/;"	f	class:Colour
Colour	algebra.hpp	/^  Colour(const Colour& other)$/;"	f	class:Colour
Colour	algebra.hpp	/^  Colour(double c)$/;"	f	class:Colour
Colour	algebra.hpp	/^  Colour(double r, double g, double b)$/;"	f	class:Colour
Colour	algebra.hpp	/^class Colour$/;"	c
ColourVector	algebra.hpp	/^typedef std::vector<Colour> ColourVector;$/;"	t
Cube	primitive.cpp	/^Cube::Cube() {$/;"	f	class:Cube
Cube	primitive.cpp	/^Cube::Cube(const Cube& other) : Primitive(other) {}$/;"	f	class:Cube
Cube	primitive.hpp	/^class Cube : public Primitive {$/;"	c
DEFINES	Makefile	/^DEFINES       = -DQT_NO_DEBUG -DQT_WIDGETS_LIB -DQT_GUI_LIB -DQT_CORE_LIB$/;"	m
DEL_DIR	Makefile	/^DEL_DIR       = rmdir$/;"	m
DEL_FILE	Makefile	/^DEL_FILE      = rm -f$/;"	m
DESTDIR	Makefile	/^DESTDIR       = #avoid trailing-slash linebreak$/;"	m
DIST	Makefile	/^DIST          = \/usr\/lib\/i386-linux-gnu\/qt5\/mkspecs\/features\/spec_pre.prf \\$/;"	m
DirectoryOfThisScript	.ycm_extra_conf.py	/^def DirectoryOfThisScript():$/;"	f
FRAMERATE	paintcanvas.cpp	19;"	d	file:
Face	mesh.hpp	/^    typedef std::vector<int> Face;$/;"	t	class:Mesh
FlagsForFile	.ycm_extra_conf.py	/^def FlagsForFile( filename, **kwargs ):$/;"	f
G	algebra.hpp	/^  double G() const $/;"	f	class:Colour
GRLUA_DEBUG	scene_lua.cpp	54;"	d	file:
GRLUA_DEBUG	scene_lua.cpp	57;"	d	file:
GRLUA_DEBUG_CALL	scene_lua.cpp	55;"	d	file:
GRLUA_DEBUG_CALL	scene_lua.cpp	58;"	d	file:
Game	game.cpp	/^Game::Game(int width, int height)$/;"	f	class:Game
Game	game.hpp	/^class Game$/;"	c
GeometryNode	scene.cpp	/^GeometryNode::GeometryNode(const std::string& name, Primitive* primitive)$/;"	f	class:GeometryNode
GeometryNode	scene.hpp	/^class GeometryNode : public SceneNode {$/;"	c
GetCompilationInfoForFile	.ycm_extra_conf.py	/^def GetCompilationInfoForFile( filename ):$/;"	f
INCPATH	Makefile	/^INCPATH       = -I\/usr\/lib\/i386-linux-gnu\/qt5\/mkspecs\/linux-g++ -I. -I. -I\/usr\/include\/lua5.1 -I\/usr\/include\/qt5 -I\/usr\/include\/qt5\/QtWidgets -I\/usr\/include\/qt5\/QtGui -I\/usr\/include\/qt5\/QtCore -I.$/;"	m
INSTALL_DIR	Makefile	/^INSTALL_DIR   = $(COPY_DIR)$/;"	m
INSTALL_FILE	Makefile	/^INSTALL_FILE  = install -m 644 -p$/;"	m
INSTALL_PROGRAM	Makefile	/^INSTALL_PROGRAM = install -m 755 -p$/;"	m
INTERSECTION_HPP	intersection.hpp	2;"	d
IVector3D	interval.cpp	/^IVector3D::IVector3D() {$/;"	f	class:IVector3D
IVector3D	interval.cpp	/^IVector3D::IVector3D(const IVector3D& other) {$/;"	f	class:IVector3D
IVector3D	interval.cpp	/^IVector3D::IVector3D(const Interval& ix, const Interval& iy, const Interval& iz) {$/;"	f	class:IVector3D
IVector3D	interval.cpp	/^IVector3D::IVector3D(const Point3D& point) {$/;"	f	class:IVector3D
IVector3D	interval.cpp	/^IVector3D::IVector3D(const Vector3D& vec) {$/;"	f	class:IVector3D
IVector3D	interval.hpp	/^class IVector3D {$/;"	c
Image	image.cpp	/^Image::Image()$/;"	f	class:Image
Image	image.cpp	/^Image::Image(const Image& other)$/;"	f	class:Image
Image	image.cpp	/^Image::Image(int width, int height, int elements)$/;"	f	class:Image
Image	image.hpp	/^class Image {$/;"	c
Intersection	intersection.cpp	/^Intersection::Intersection(const Intersection& other) {$/;"	f	class:Intersection
Intersection	intersection.cpp	/^Intersection::Intersection(const Point3D& point, double t, PhongMaterial* material, const Vector3D& normal):$/;"	f	class:Intersection
Intersection	intersection.hpp	/^    Intersection() {};$/;"	f	class:Intersection
Intersection	intersection.hpp	/^class Intersection {$/;"	c
Interval	interval.cpp	/^Interval::Interval() : m_empty(true)$/;"	f	class:Interval
Interval	interval.cpp	/^Interval::Interval(const Interval& other) {$/;"	f	class:Interval
Interval	interval.cpp	/^Interval::Interval(double low, double high)$/;"	f	class:Interval
Interval	interval.cpp	/^Interval::Interval(double val) : Interval(val, val) {}$/;"	f	class:Interval
Interval	interval.hpp	/^class Interval {$/;"	c
IsHeaderFile	.ycm_extra_conf.py	/^def IsHeaderFile( filename ):$/;"	f
JointNode	scene.cpp	/^JointNode::JointNode(const std::string& name)$/;"	f	class:JointNode
JointNode	scene.hpp	/^class JointNode : public SceneNode {$/;"	c
JointRange	scene.hpp	/^    struct JointRange {$/;"	s	class:JointNode
LFLAGS	Makefile	/^LFLAGS        = -Wl,-O1$/;"	m
LIBS	Makefile	/^LIBS          = $(SUBLIBS) -llua5.1 -lQt5Widgets -L\/usr\/lib\/i386-linux-gnu -lQt5Gui -lQt5Core -lGL -lpthread $/;"	m
LINK	Makefile	/^LINK          = g++$/;"	m
LUA_HPP	lua488.hpp	2;"	d
Light	light.cpp	/^Light::Light()$/;"	f	class:Light
Light	light.hpp	/^struct Light {$/;"	s
MAKEFILE	Makefile	/^MAKEFILE      = Makefile$/;"	m
MAX_DEPTH	bih.cpp	15;"	d	file:
MAX_DEPTH	tracer.cpp	12;"	d	file:
MKDIR	Makefile	/^MKDIR         = mkdir -p$/;"	m
MOVE	Makefile	/^MOVE          = mv -f$/;"	m
M_PI	algebra.hpp	23;"	d
MakeRelativePathsInFlagsAbsolute	.ycm_extra_conf.py	/^def MakeRelativePathsInFlagsAbsolute( flags, working_directory ):$/;"	f
Material	material.hpp	/^  Material()$/;"	f	class:Material
Material	material.hpp	/^class Material {$/;"	c
Matrix4x4	algebra.hpp	/^  Matrix4x4()$/;"	f	class:Matrix4x4
Matrix4x4	algebra.hpp	/^  Matrix4x4(const Matrix4x4& other)$/;"	f	class:Matrix4x4
Matrix4x4	algebra.hpp	/^  Matrix4x4(const Vector4D row1, const Vector4D row2, const Vector4D row3, $/;"	f	class:Matrix4x4
Matrix4x4	algebra.hpp	/^  Matrix4x4(double *vals)$/;"	f	class:Matrix4x4
Matrix4x4	algebra.hpp	/^class Matrix4x4$/;"	c
Mesh	mesh.cpp	/^Mesh::Mesh(const Mesh& other) : Primitive(other)$/;"	f	class:Mesh
Mesh	mesh.cpp	/^Mesh::Mesh(const std::vector<Point3D>& verts,$/;"	f	class:Mesh
Mesh	mesh.hpp	/^class Mesh : public Primitive {$/;"	c
NUMTHREADS	paintcanvas.hpp	/^    static const int NUMTHREADS = 8;$/;"	m	class:PaintCanvas
Node	bih.cpp	/^        Node(BIHNode* node, int firstActive) :$/;"	f	struct:__anon3::Node
Node	bih.cpp	/^    struct Node{$/;"	s	namespace:__anon3	file:
NonhierBox	primitive.cpp	/^NonhierBox::NonhierBox(const NonhierBox& other) : Primitive(other)$/;"	f	class:NonhierBox
NonhierBox	primitive.cpp	/^NonhierBox::NonhierBox(const Point3D& pos, double size) :$/;"	f	class:NonhierBox
NonhierBox	primitive.hpp	/^class NonhierBox : public Primitive {$/;"	c
NonhierSphere	primitive.cpp	/^NonhierSphere::NonhierSphere(const NonhierSphere& other) : Primitive(other)$/;"	f	class:NonhierSphere
NonhierSphere	primitive.cpp	/^NonhierSphere::NonhierSphere(const Point3D& pos, double radius) :$/;"	f	class:NonhierSphere
NonhierSphere	primitive.hpp	/^class NonhierSphere : public Primitive {$/;"	c
OBJECTS	Makefile	/^OBJECTS       = a4.o \\$/;"	m
OBJECTS_DIR	Makefile	/^OBJECTS_DIR   = .\/$/;"	m
PACKET_WIDTH	packet.cpp	11;"	d	file:
PAINTCANVAS_HPP	paintcanvas.hpp	5;"	d
PAINTWINDOW_HPP	paintwindow.hpp	5;"	d
PIECES	game.cpp	/^static const Piece PIECES[] = {$/;"	v	file:
Packet	packet.cpp	/^Packet::Packet() $/;"	f	class:Packet
Packet	packet.cpp	/^Packet::Packet(const Packet& other) {$/;"	f	class:Packet
Packet	packet.hpp	/^class Packet {$/;"	c
PaintCanvas	paintcanvas.cpp	/^PaintCanvas::PaintCanvas(QWidget *parent, Camera* cam, const list<Light*>* lights, Colour ambient, $/;"	f	class:PaintCanvas
PaintCanvas	paintcanvas.hpp	/^class PaintCanvas : public QWidget {$/;"	c
PaintWindow	paintwindow.cpp	/^PaintWindow::PaintWindow(Camera* cam, const list<Light*>* lights, const Colour& ambient, $/;"	f	class:PaintWindow
PaintWindow	paintwindow.hpp	/^class PaintWindow : public QMainWindow$/;"	c
PhongMaterial	material.cpp	/^PhongMaterial::PhongMaterial(const Colour& kd, const Colour& ks, double shininess, double transmitRatio, double medium)$/;"	f	class:PhongMaterial
PhongMaterial	material.hpp	/^class PhongMaterial : public Material {$/;"	c
Piece	game.cpp	/^Piece::Piece()$/;"	f	class:Piece
Piece	game.cpp	/^Piece::Piece(const char *desc, int cindex, $/;"	f	class:Piece
Piece	game.hpp	/^class Piece {$/;"	c
Point2D	algebra.hpp	/^  Point2D()$/;"	f	class:Point2D
Point2D	algebra.hpp	/^  Point2D(const Point2D& other)$/;"	f	class:Point2D
Point2D	algebra.hpp	/^  Point2D(double x, double y)$/;"	f	class:Point2D
Point2D	algebra.hpp	/^class Point2D$/;"	c
Point3D	algebra.cpp	/^Point3D::Point3D(const Vector4D& vec) {$/;"	f	class:Point3D
Point3D	algebra.hpp	/^  Point3D()$/;"	f	class:Point3D
Point3D	algebra.hpp	/^  Point3D(const Point3D& other)$/;"	f	class:Point3D
Point3D	algebra.hpp	/^  Point3D(double x, double y, double z)$/;"	f	class:Point3D
Point3D	algebra.hpp	/^class Point3D$/;"	c
PolishRoot	polyroots.cpp	/^static double PolishRoot( $/;"	f	file:
Polygon	mesh.cpp	/^Polygon::Polygon(const Polygon& other) : Primitive(other) $/;"	f	class:Polygon
Polygon	mesh.cpp	/^Polygon::Polygon(const std::vector<Point3D>& verts, const std::vector<int>& indices,$/;"	f	class:Polygon
Polygon	mesh.hpp	/^class Polygon : public Primitive {$/;"	c
Primitive	primitive.cpp	/^Primitive::Primitive(const Primitive& other) {$/;"	f	class:Primitive
Primitive	primitive.hpp	/^    Primitive() {}$/;"	f	class:Primitive
Primitive	primitive.hpp	/^class Primitive {$/;"	c
QMAKE	Makefile	/^QMAKE         = \/usr\/lib\/i386-linux-gnu\/qt5\/bin\/qmake$/;"	m
QMAKE_TARGET	Makefile	/^QMAKE_TARGET  = rt$/;"	m
QT_MOC_LITERAL	moc_paintcanvas.cpp	25;"	d	file:
QT_MOC_LITERAL	moc_paintcanvas.cpp	41;"	d	file:
QT_MOC_LITERAL	moc_paintwindow.cpp	25;"	d	file:
QT_MOC_LITERAL	moc_paintwindow.cpp	36;"	d	file:
R	algebra.hpp	/^  double R() const $/;"	f	class:Colour
RANLIB	Makefile	/^RANLIB        = $/;"	m
RAY_HPP	ray.hpp	2;"	d
REFLECTION_ATTENUATION	tracer.cpp	13;"	d	file:
Ray	ray.cpp	/^Ray::Ray(Point3D origin, Point3D endpoint, double epsilon) {$/;"	f	class:Ray
Ray	ray.cpp	/^Ray::Ray(Point3D origin, Vector3D direction, double epsilon) {$/;"	f	class:Ray
Ray	ray.cpp	/^Ray::Ray(const Ray& other) {$/;"	f	class:Ray
Ray	ray.hpp	/^    Ray() {}$/;"	f	class:Ray
Ray	ray.hpp	/^class Ray {$/;"	c
SAMPLE	sample.hpp	2;"	d
SAMPLE_WIDTH	packet.cpp	10;"	d	file:
SCENE_HPP	scene.hpp	2;"	d
SCENE_LUA_HPP	scene_lua.hpp	2;"	d
SED	Makefile	/^SED           = sed$/;"	m
SIGN	polyroots.cpp	83;"	d	file:
SOURCES	Makefile	/^SOURCES       = a4.cpp \\$/;"	m
SOURCE_EXTENSIONS	.ycm_extra_conf.py	/^SOURCE_EXTENSIONS = [ '.cpp', '.cxx', '.cc', '.c', '.m', '.mm' ]$/;"	v
SQRT3	polyroots.cpp	80;"	d	file:
STRIP	Makefile	/^STRIP         = strip$/;"	m
SYMLINK	Makefile	/^SYMLINK       = ln -f -s$/;"	m
Sample	sample.hpp	/^class Sample {$/;"	c
SceneNode	scene.cpp	/^SceneNode::SceneNode(const std::string& name)$/;"	f	class:SceneNode
SceneNode	scene.hpp	/^class SceneNode {$/;"	c
Sphere	primitive.cpp	/^Sphere::Sphere() {$/;"	f	class:Sphere
Sphere	primitive.cpp	/^Sphere::Sphere(const Sphere& other) : Primitive(other) {}$/;"	f	class:Sphere
Sphere	primitive.hpp	/^class Sphere : public Primitive {$/;"	c
TAR	Makefile	/^TAR           = tar -cf$/;"	m
TARGET	Makefile	/^TARGET        = rt$/;"	m
TRACER_HPP	tracer.hpp	2;"	d
TetrisNode	scene.cpp	/^TetrisNode::TetrisNode(const string& name) : $/;"	f	class:TetrisNode
TetrisNode	scene.hpp	/^class TetrisNode : public SceneNode {$/;"	c
Tracer	tracer.cpp	/^Tracer::Tracer(std::vector<Primitive*>* primitives, const Colour& ambient, const std::list<Light*>* lights) :$/;"	f	class:Tracer
Tracer	tracer.hpp	/^class Tracer {$/;"	c
Triangle	mesh.cpp	/^Triangle::Triangle(const Triangle& other) : Polygon(other)$/;"	f	class:Triangle
Triangle	mesh.cpp	/^Triangle::Triangle(const std::vector<Point3D>& verts, const std::vector<int>& indices, const Matrix4x4& trans) :$/;"	f	class:Triangle
Triangle	mesh.hpp	/^class Triangle : public Polygon {$/;"	c
Type	bih.hpp	/^    enum Type {$/;"	g	class:BIHNode
Vector3D	algebra.cpp	/^Vector3D::Vector3D(const Vector4D& vec) {$/;"	f	class:Vector3D
Vector3D	algebra.hpp	/^  Vector3D()$/;"	f	class:Vector3D
Vector3D	algebra.hpp	/^  Vector3D(const Point3D& p) {$/;"	f	class:Vector3D
Vector3D	algebra.hpp	/^  Vector3D(const Vector3D& other)$/;"	f	class:Vector3D
Vector3D	algebra.hpp	/^  Vector3D(double x, double y, double z)$/;"	f	class:Vector3D
Vector3D	algebra.hpp	/^class Vector3D$/;"	c
Vector4D	algebra.hpp	/^  Vector4D()$/;"	f	class:Vector4D
Vector4D	algebra.hpp	/^  Vector4D(const Point3D& point, double w = 1.0) {$/;"	f	class:Vector4D
Vector4D	algebra.hpp	/^  Vector4D(const Vector3D& vec, double w = 0.0) {$/;"	f	class:Vector4D
Vector4D	algebra.hpp	/^  Vector4D(const Vector4D& other)$/;"	f	class:Vector4D
Vector4D	algebra.hpp	/^  Vector4D(double x, double y, double z, double w)$/;"	f	class:Vector4D
Vector4D	algebra.hpp	/^class Vector4D$/;"	c
addMeshPolygons	mesh.cpp	/^void Mesh::addMeshPolygons(vector<Primitive*>* primitives) {$/;"	f	class:Mesh
add_child	scene.hpp	/^    void add_child(SceneNode* child)$/;"	f	class:SceneNode
allMiss	bbox.cpp	/^bool AABB::allMiss(const Packet& packet) {$/;"	f	class:AABB
allMiss	primitive.cpp	/^bool Primitive::allMiss(const Packet& packet) {$/;"	f	class:Primitive
b_	algebra.hpp	/^  double b_;$/;"	m	class:Colour
begin	algebra.hpp	/^  const double *begin() const$/;"	f	class:Matrix4x4
board_	game.hpp	/^  int* board_;$/;"	m	class:Game
board_height_	game.hpp	/^  int board_height_;$/;"	m	class:Game
board_width_	game.hpp	/^  int board_width_;$/;"	m	class:Game
buildBorder	scene.cpp	/^void TetrisNode::buildBorder(const Matrix4x4& trans, const Matrix4x4& inv) {$/;"	f	class:TetrisNode
buildHierarchy	bih.cpp	/^void BIHNode::buildHierarchy(stack<BIHNode*>* nodes, stack<AABB>* bboxes, const AABB& uniformBBox) {$/;"	f	class:BIHNode
buildPieces	scene.cpp	/^void TetrisNode::buildPieces(const Matrix4x4& trans, const Matrix4x4& inv, Game* game) {$/;"	f	class:TetrisNode
castReflectionRay	tracer.cpp	/^Colour Tracer::castReflectionRay(const Ray& ray, Intersection* isect, int depth) {$/;"	f	class:Tracer
castReflectionRays	tracer.cpp	/^void Tracer::castReflectionRays(const vector<Ray*>* rays, ColourVector* colours, $/;"	f	class:Tracer
castRefractionRay	tracer.cpp	/^Colour Tracer::castRefractionRay(const Ray& ray, Intersection* isect, int depth) {$/;"	f	class:Tracer
castRefractionRays	tracer.cpp	/^void Tracer::castRefractionRays(const vector<Ray*>* rays, ColourVector* colours, $/;"	f	class:Tracer
castShadowRays	tracer.cpp	/^Colour Tracer::castShadowRays(const Ray& ray, Intersection* isect) {$/;"	f	class:Tracer
castShadowRays	tracer.cpp	/^void Tracer::castShadowRays(const vector<Ray*>* rays, ColourVector* colours, $/;"	f	class:Tracer
cbrt	polyroots.cpp	/^static double cbrt( double t )$/;"	f	file:
checkParam	ray.cpp	/^bool Ray::checkParam(double t) const {$/;"	f	class:Ray
chooseAxis	bih.cpp	/^BIHNode::Type BIHNode::chooseAxis(const AABB& bbox) {$/;"	f	class:BIHNode
cindex_	game.hpp	/^  int cindex_;$/;"	m	class:Piece
clamp	material.cpp	/^static double clamp(double val, double min, double max) {$/;"	f	file:
clone	mesh.hpp	/^    virtual Mesh* clone() { return new Mesh(*this); }$/;"	f	class:Mesh
clone	mesh.hpp	/^    virtual Polygon* clone() { return new Polygon(*this); }$/;"	f	class:Polygon
clone	mesh.hpp	/^    virtual Triangle* clone() { return new Triangle(*this); }$/;"	f	class:Triangle
clone	primitive.hpp	/^    virtual Cube* clone() { return new Cube(*this); }$/;"	f	class:Cube
clone	primitive.hpp	/^    virtual NonhierBox* clone() { return new NonhierBox(*this); }$/;"	f	class:NonhierBox
clone	primitive.hpp	/^    virtual NonhierSphere* clone() { return new NonhierSphere(*this); }$/;"	f	class:NonhierSphere
clone	primitive.hpp	/^    virtual Sphere* clone() { return new Sphere(*this); }$/;"	f	class:Sphere
collapse	game.cpp	/^int Game::collapse() $/;"	f	class:Game
colour	light.hpp	/^  Colour colour;$/;"	m	struct:Light
compilation_database_folder	.ycm_extra_conf.py	/^compilation_database_folder = ''$/;"	v
computePixels	paintcanvas.cpp	/^void PaintCanvas::computePixels() {$/;"	f	class:PaintCanvas
computeQImage	paintcanvas.cpp	/^void PaintCanvas::computeQImage() {$/;"	f	class:PaintCanvas
contains	bbox.cpp	/^bool AABB::contains(const Ray& ray) const{$/;"	f	class:AABB
copy	camera.cpp	/^void Camera::copy(const Camera& other) {$/;"	f	class:Camera
copy	interval.cpp	/^void IVector3D::copy(const IVector3D& other) {$/;"	f	class:IVector3D
copy	interval.cpp	/^void Interval::copy(const Interval& other) {$/;"	f	class:Interval
copy	packet.cpp	/^void CameraPacket::copy(const CameraPacket& other) {$/;"	f	class:CameraPacket
copy	packet.cpp	/^void Packet::copy(const Packet& other) {$/;"	f	class:Packet
copy	ray.cpp	/^void Ray::copy(const Ray& other) {$/;"	f	class:Ray
cosk_lookup	polyroots.cpp	/^static double cosk_lookup(double t)$/;"	f	file:
createMenu	paintwindow.cpp	/^void PaintWindow::createMenu() {$/;"	f	class:PaintWindow
cross	algebra.hpp	/^  Vector3D cross(const Vector3D& other) const$/;"	f	class:Vector3D
cross	algebra.hpp	/^inline Vector3D cross(const Vector3D& a, const Vector3D& b) $/;"	f
cubicRoots	polyroots.cpp	/^size_t cubicRoots( double p, double q, double r, double roots[3] )$/;"	f
data	image.cpp	/^const double* Image::data() const$/;"	f	class:Image
data	image.cpp	/^double* Image::data()$/;"	f	class:Image
data	moc_paintcanvas.cpp	/^    QByteArrayData data[5];$/;"	m	struct:qt_meta_stringdata_PaintCanvas_t	file:
data	moc_paintwindow.cpp	/^    QByteArrayData data[1];$/;"	m	struct:qt_meta_stringdata_PaintWindow_t	file:
database	.ycm_extra_conf.py	/^  database = None$/;"	v
database	.ycm_extra_conf.py	/^  database = ycm_core.CompilationDatabase( compilation_database_folder )$/;"	v
deletePackets	packet.cpp	/^void CameraPacket::deletePackets(vector<CameraPacket*>* packets) {$/;"	f	class:CameraPacket
deletePieces	scene.cpp	/^void TetrisNode::deletePieces() {$/;"	f	class:TetrisNode
desc_	game.hpp	/^  char desc_[16];$/;"	m	class:Piece
dividerow	algebra.cpp	/^static void dividerow(Matrix4x4& a, size_t r, double fac)$/;"	f	file:
doesPieceFit	game.cpp	/^bool Game::doesPieceFit(const Piece& p, int x, int y) const$/;"	f	class:Game
dot	algebra.hpp	/^  double dot(const Vector3D& other) const$/;"	f	class:Vector3D
dot	interval.hpp	/^    Interval dot(const IVector3D& other) const$/;"	f	class:IVector3D
drop	game.cpp	/^bool Game::drop()$/;"	f	class:Game
elements	image.cpp	/^int Image::elements() const$/;"	f	class:Image
end	algebra.hpp	/^  const double *end() const$/;"	f	class:Matrix4x4
extend	interval.cpp	/^void IVector3D::extend(const Point3D& point) {$/;"	f	class:IVector3D
extend	interval.cpp	/^void IVector3D::extend(const Vector3D& vec) {$/;"	f	class:IVector3D
extend	interval.cpp	/^void Interval::extend(double val) {$/;"	f	class:Interval
fabs	polyroots.cpp	77;"	d	file:
falloff	light.hpp	/^  double falloff[3];$/;"	m	struct:Light
flags	.ycm_extra_conf.py	/^flags = [$/;"	v
g_	algebra.hpp	/^  double g_;$/;"	m	class:Colour
genPackets	packet.cpp	/^vector<CameraPacket*>* CameraPacket::genPackets(QImage* img, Tracer* tracer, const Camera& cam) {$/;"	f	class:CameraPacket
genRays	packet.cpp	/^void CameraPacket::genRays(const Camera& cam) {$/;"	f	class:CameraPacket
generateNewPiece	game.cpp	/^void Game::generateNewPiece() $/;"	f	class:Game
get	game.cpp	/^int Game::get(int r, int c) const$/;"	f	class:Game
get	game.cpp	/^int& Game::get(int r, int c) $/;"	f	class:Game
getBottomMargin	game.cpp	/^int Piece::getBottomMargin() const$/;"	f	class:Piece
getColour	material.cpp	/^Colour PhongMaterial::getColour(const Vector3D& l, const Vector3D& v, const Intersection* isect, const Light& light) {$/;"	f	class:PhongMaterial
getColourIndex	game.cpp	/^int Piece::getColourIndex() const$/;"	f	class:Piece
getColumn	algebra.hpp	/^  Vector4D getColumn(size_t col) const$/;"	f	class:Matrix4x4
getColumn	game.cpp	/^void Piece::getColumn(int col, char *buf) const$/;"	f	class:Piece
getColumnRev	game.cpp	/^void Piece::getColumnRev(int col, char *buf) const$/;"	f	class:Piece
getDirReciproc	packet.hpp	/^    IVector3D getDirReciproc() const { return m_dirReciproc; }$/;"	f	class:Packet
getDirection	packet.hpp	/^    IVector3D getDirection() const { return m_direction; }$/;"	f	class:Packet
getDirection	ray.hpp	/^    const Vector3D& getDirection() const { return m_direction; }$/;"	f	class:Ray
getEpsilon	ray.hpp	/^    double getEpsilon() const { return m_epsilon; }$/;"	f	class:Ray
getEye	camera.hpp	/^    Point3D getEye() const { return m_eye; }$/;"	f	class:Camera
getHeight	camera.hpp	/^    int getHeight() const { return m_height; }$/;"	f	class:Camera
getHeight	game.hpp	/^  int getHeight() const$/;"	f	class:Game
getInnerPoint	mesh.cpp	/^Point3D Mesh::getInnerPoint(const Face& poly) {$/;"	f	class:Mesh
getIntensity	light.cpp	/^Colour Light::getIntensity(Point3D& point) const {$/;"	f	class:Light
getIntersection	bih.cpp	/^bool BIHNode::getIntersection(const Ray& ray, Intersection* isect) {$/;"	f	class:BIHNode
getIntersection	bih.cpp	/^bool BIHTree::getIntersection(const Ray& ray, Intersection* isect) {$/;"	f	class:BIHTree
getIntersection	bih.cpp	/^void BIHTree::getIntersection(Packet& packet, vector<bool>& v_hit, vector<Intersection>* v_isect) {$/;"	f	class:BIHTree
getIntersection	mesh.cpp	/^bool Mesh::getIntersection(const Ray& ray, Intersection* isect) {$/;"	f	class:Mesh
getIntersection	mesh.cpp	/^bool Polygon::getIntersection(const Ray& ray, Intersection* isect) {$/;"	f	class:Polygon
getIntersection	primitive.cpp	/^bool Cube::getIntersection(const Ray& ray, Intersection* isect) {$/;"	f	class:Cube
getIntersection	primitive.cpp	/^bool NonhierBox::getIntersection(const Ray& ray, Intersection* isect) {$/;"	f	class:NonhierBox
getIntersection	primitive.cpp	/^bool NonhierSphere::getIntersection(const Ray& ray, Intersection* isect) {$/;"	f	class:NonhierSphere
getIntersection	primitive.cpp	/^bool Sphere::getIntersection(const Ray& ray, Intersection* isect) {$/;"	f	class:Sphere
getIntersection	primitive.cpp	/^void Primitive::getIntersection(Packet& packet, int firstActive, vector<bool>& v_hit, vector<Intersection>* v_isect) {$/;"	f	class:Primitive
getIntersection	tracer.cpp	/^bool Tracer::getIntersection(const Ray& ray, Intersection* isect) {$/;"	f	class:Tracer
getKD	material.hpp	/^  Colour getKD() const { return m_kd; }$/;"	f	class:PhongMaterial
getKS	material.hpp	/^  Colour getKS() const { return m_ks; }$/;"	f	class:PhongMaterial
getLeafIntersection	bih.cpp	/^bool BIHNode::getLeafIntersection(const Ray& ray, Intersection* isect) {$/;"	f	class:BIHNode
getLeftBBox	bih.cpp	/^AABB BIHNode::getLeftBBox(const AABB& bbox, double plane) {$/;"	f	class:BIHNode
getLeftMargin	game.cpp	/^int Piece::getLeftMargin() const$/;"	f	class:Piece
getLength	packet.hpp	/^    double getLength() const { return m_length; }$/;"	f	class:Packet
getLength	ray.hpp	/^    double getLength() const { return m_length; }$/;"	f	class:Ray
getLineNormal	mesh.cpp	/^static Vector3D getLineNormal(const Point3D& p1, const Point3D& p2, const Point3D& innerPoint, const Vector3D& polyNormal) {$/;"	f	file:
getMaterial	intersection.hpp	/^    PhongMaterial* getMaterial() const { return m_material; }$/;"	f	class:Intersection
getMaterial	primitive.hpp	/^    PhongMaterial* getMaterial() const { return m_material; }$/;"	f	class:Primitive
getMaxIndex	mesh.cpp	/^int getMaxIndex(Vector3D& vec) {$/;"	f
getMedian	bbox.hpp	/^inline double AABB::getMedian(int axis) const {$/;"	f	class:AABB
getMedium	material.hpp	/^  double getMedium() const { return m_medium; }$/;"	f	class:PhongMaterial
getNormal	intersection.hpp	/^    Vector3D getNormal() const { return m_normal; }$/;"	f	class:Intersection
getOrigin	packet.hpp	/^    IVector3D getOrigin() const { return m_origin; }$/;"	f	class:Packet
getOrigin	ray.hpp	/^    const Point3D& getOrigin() const { return m_origin; }$/;"	f	class:Ray
getParam	intersection.hpp	/^    double getParam() const { return m_param; }$/;"	f	class:Intersection
getPlaneIntersection	mesh.cpp	/^bool Mesh::getPlaneIntersection(const Face& poly, const Ray& ray, Intersection* isect) {$/;"	f	class:Mesh
getPlaneIntersection	mesh.cpp	/^bool Polygon::getPlaneIntersection(const Ray& ray, Intersection* isect) {$/;"	f	class:Polygon
getPoint	intersection.hpp	/^    Point3D getPoint() const { return m_point; }$/;"	f	class:Intersection
getPolyIntersection	mesh.cpp	/^bool Mesh::getPolyIntersection(const Face& poly, Intersection* isect) {$/;"	f	class:Mesh
getPolyNormal	mesh.cpp	/^Vector3D Mesh::getPolyNormal(const Face& poly) {$/;"	f	class:Mesh
getPrimitives	scene.cpp	/^void GeometryNode::getPrimitives(vector<Primitive*>* primitives, const Matrix4x4& trans, const Matrix4x4& inv, Game* game) {$/;"	f	class:GeometryNode
getPrimitives	scene.cpp	/^void SceneNode::getPrimitives(vector<Primitive*>* primitives, Game* game) {$/;"	f	class:SceneNode
getPrimitives	scene.cpp	/^void SceneNode::getPrimitives(vector<Primitive*>* primitives, const Matrix4x4& trans, const Matrix4x4& inv, Game* game) {$/;"	f	class:SceneNode
getPrimitives	scene.cpp	/^void TetrisNode::getPrimitives(vector<Primitive*>* primitives, const Matrix4x4& trans, const Matrix4x4& inv, Game* game) {$/;"	f	class:TetrisNode
getRay	camera.cpp	/^Ray* Camera::getRay(double xPos, double yPos) const{$/;"	f	class:Camera
getRays	packet.hpp	/^    std::vector<Ray*>* getRays() { return m_rays; }$/;"	f	class:Packet
getRefracted	tracer.cpp	/^Ray getRefracted(const Ray& ray, Intersection* isect) {$/;"	f
getRightBBox	bih.cpp	/^AABB BIHNode::getRightBBox(const AABB& bbox, double plane) {$/;"	f	class:BIHNode
getRightMargin	game.cpp	/^int Piece::getRightMargin() const$/;"	f	class:Piece
getRotMat	algebra.cpp	/^Matrix4x4 Matrix4x4::getRotMat(char axis, double angle) {$/;"	f	class:Matrix4x4
getRow	algebra.hpp	/^  Vector4D getRow(size_t row) const$/;"	f	class:Matrix4x4
getRow	algebra.hpp	/^  double *getRow(size_t row) $/;"	f	class:Matrix4x4
getScaleMat	algebra.cpp	/^Matrix4x4 Matrix4x4::getScaleMat(const Vector3D& amount) {$/;"	f	class:Matrix4x4
getShininess	material.hpp	/^  double getShininess() const { return m_shininess; }$/;"	f	class:PhongMaterial
getTopMargin	game.cpp	/^int Piece::getTopMargin() const$/;"	f	class:Piece
getTransMat	algebra.cpp	/^Matrix4x4 Matrix4x4::getTransMat(const Vector3D& amount) {$/;"	f	class:Matrix4x4
getTransform	bbox.cpp	/^AABB AABB::getTransform(const AABB& bbox, const Matrix4x4& trans) {$/;"	f	class:AABB
getTransform	ray.cpp	/^Ray Ray::getTransform(Matrix4x4& trans) const {$/;"	f	class:Ray
getTransmitRatio	material.hpp	/^  double getTransmitRatio() const { return m_transmitRatio; }$/;"	f	class:PhongMaterial
getViewToWorld	camera.cpp	/^Matrix4x4 Camera::getViewToWorld() {$/;"	f	class:Camera
getWidth	camera.hpp	/^    int getWidth() const { return m_width; }$/;"	f	class:Camera
getWidth	game.hpp	/^  int getWidth() const$/;"	f	class:Game
getWorldBBox	primitive.hpp	/^    AABB* getWorldBBox() { return &m_worldBBox; }$/;"	f	class:Primitive
get_inverse	scene.hpp	/^    const Matrix4x4& get_inverse() const { return m_inv ; }$/;"	f	class:SceneNode
get_material	scene.cpp	/^Material* GeometryNode::get_material() {$/;"	f	class:GeometryNode
get_primitive	scene.cpp	/^Primitive* GeometryNode::get_primitive() {$/;"	f	class:GeometryNode
get_transform	scene.hpp	/^    const Matrix4x4& get_transform() const { return m_trans ; }$/;"	f	class:SceneNode
get_tuple	scene_lua.cpp	/^void get_tuple(lua_State* L, int arg, T* data, int n)$/;"	f
gr_cube_cmd	scene_lua.cpp	/^int gr_cube_cmd(lua_State* L)$/;"	f
gr_joint_cmd	scene_lua.cpp	/^int gr_joint_cmd(lua_State* L)$/;"	f
gr_light_cmd	scene_lua.cpp	/^int gr_light_cmd(lua_State* L)$/;"	f
gr_light_ud	scene_lua.cpp	/^struct gr_light_ud {$/;"	s	file:
gr_material_cmd	scene_lua.cpp	/^int gr_material_cmd(lua_State* L)$/;"	f
gr_material_ud	scene_lua.cpp	/^struct gr_material_ud {$/;"	s	file:
gr_mesh_cmd	scene_lua.cpp	/^int gr_mesh_cmd(lua_State* L)$/;"	f
gr_nh_box_cmd	scene_lua.cpp	/^int gr_nh_box_cmd(lua_State* L)$/;"	f
gr_nh_sphere_cmd	scene_lua.cpp	/^int gr_nh_sphere_cmd(lua_State* L)$/;"	f
gr_node_add_child_cmd	scene_lua.cpp	/^int gr_node_add_child_cmd(lua_State* L)$/;"	f
gr_node_cmd	scene_lua.cpp	/^int gr_node_cmd(lua_State* L)$/;"	f
gr_node_gc_cmd	scene_lua.cpp	/^int gr_node_gc_cmd(lua_State* L)$/;"	f
gr_node_rotate_cmd	scene_lua.cpp	/^int gr_node_rotate_cmd(lua_State* L)$/;"	f
gr_node_scale_cmd	scene_lua.cpp	/^int gr_node_scale_cmd(lua_State* L)$/;"	f
gr_node_set_material_cmd	scene_lua.cpp	/^int gr_node_set_material_cmd(lua_State* L)$/;"	f
gr_node_translate_cmd	scene_lua.cpp	/^int gr_node_translate_cmd(lua_State* L)$/;"	f
gr_node_ud	scene_lua.cpp	/^struct gr_node_ud {$/;"	s	file:
gr_render_cmd	scene_lua.cpp	/^int gr_render_cmd(lua_State* L)$/;"	f
gr_sphere_cmd	scene_lua.cpp	/^int gr_sphere_cmd(lua_State* L)$/;"	f
gr_tetris_cmd	scene_lua.cpp	/^int gr_tetris_cmd(lua_State* L)$/;"	f
grlib_functions	scene_lua.cpp	/^static const luaL_reg grlib_functions[] = {$/;"	v	file:
grlib_node_methods	scene_lua.cpp	/^static const luaL_reg grlib_node_methods[] = {$/;"	v	file:
hasEndpoint	ray.hpp	/^    bool hasEndpoint() const { return m_hasEndpoint; }$/;"	f	class:Ray
height	image.cpp	/^int Image::height() const$/;"	f	class:Image
init	scene.hpp	/^        double min, init, max;$/;"	m	struct:JointNode::JointRange
initGame	scene.cpp	/^bool SceneNode::initGame(Game*& game) {$/;"	f	class:SceneNode
initGame	scene.cpp	/^bool TetrisNode::initGame(Game*& game) {$/;"	f	class:TetrisNode
initGlobalBBox	bih.cpp	/^void BIHTree::initGlobalBBox() {$/;"	f	class:BIHTree
initPieceTypes	scene.cpp	/^void TetrisNode::initPieceTypes() {$/;"	f	class:TetrisNode
intersect	bbox.cpp	/^bool AABB::intersect(const Ray& ray) const{$/;"	f	class:AABB
intersectMembers	interval.cpp	/^Interval IVector3D::intersectMembers() {$/;"	f	class:IVector3D
invert	algebra.cpp	/^Matrix4x4 Matrix4x4::invert() const$/;"	f	class:Matrix4x4
isDiffuse	material.hpp	/^  inline bool isDiffuse() const { return m_kd.R() > 1.0e-10 || m_kd.G() > 1.0e-10 || m_kd.B() > 1.0e-10; }$/;"	f	class:PhongMaterial
isEmpty	interval.hpp	/^    bool isEmpty() { return m_empty; }$/;"	f	class:Interval
isFinite	packet.hpp	/^    bool isFinite() const { return m_finite; }$/;"	f	class:Packet
isGameOver	game.hpp	/^  bool isGameOver() { return stopped_; }$/;"	f	class:Game
isMesh	mesh.hpp	/^    virtual bool isMesh() { return true; }$/;"	f	class:Mesh
isMesh	primitive.hpp	/^    virtual bool isMesh() { return false; }$/;"	f	class:Primitive
isOn	game.cpp	/^bool Piece::isOn(int row, int col) const$/;"	f	class:Piece
isSpecular	material.hpp	/^  inline bool isSpecular() const { return m_ks.R() > 1.0e-10 || m_ks.G() > 1.0e-10 || m_ks.B() > 1.0e-10; }$/;"	f	class:PhongMaterial
is_joint	scene.cpp	/^bool JointNode::is_joint() const$/;"	f	class:JointNode
is_joint	scene.cpp	/^bool SceneNode::is_joint() const$/;"	f	class:SceneNode
launch_qt	a4.cpp	/^bool launch_qt(\/\/ What to render$/;"	f
leaf	bih.hpp	/^        leaf$/;"	e	enum:BIHNode::Type
length	algebra.hpp	/^  double length() const$/;"	f	class:Vector3D
length2	algebra.hpp	/^  double length2() const$/;"	f	class:Vector3D
less	interval.cpp	/^bool Interval::less(const Interval& a, const Interval& b) {$/;"	f	class:Interval
light	scene_lua.cpp	/^  Light* light;$/;"	m	struct:gr_light_ud	file:
loadPng	image.cpp	/^bool Image::loadPng(const std::string& filename)$/;"	f	class:Image
m_ambient	paintcanvas.hpp	/^    Colour m_ambient;$/;"	m	class:PaintCanvas
m_ambient	tracer.hpp	/^    Colour m_ambient;$/;"	m	class:Tracer
m_bbox	bih.hpp	/^    AABB m_bbox;$/;"	m	class:BIHNode
m_bih	tracer.hpp	/^    BIHTree* m_bih;    $/;"	m	class:Tracer
m_border	scene.hpp	/^    std::vector<Primitive*> m_border;    $/;"	m	class:TetrisNode
m_cam	paintcanvas.hpp	/^    Camera* m_cam;$/;"	m	class:PaintCanvas
m_cam	tracer.hpp	/^    const Camera* m_cam;$/;"	m	class:Tracer
m_canvas	paintwindow.hpp	/^    PaintCanvas* m_canvas;$/;"	m	class:PaintWindow
m_children	bih.hpp	/^        BIHNode* m_children;$/;"	m	union:BIHNode::__anon1
m_children	scene.hpp	/^    ChildList m_children;$/;"	m	class:SceneNode
m_data	image.hpp	/^  double* m_data;$/;"	m	class:Image
m_depth	bih.hpp	/^    int m_depth;$/;"	m	class:BIHNode
m_dirReciproc	packet.hpp	/^    IVector3D m_dirReciproc;$/;"	m	class:Packet
m_direction	packet.hpp	/^    IVector3D m_direction;$/;"	m	class:Packet
m_direction	ray.hpp	/^    Vector3D m_direction;$/;"	m	class:Ray
m_elements	image.hpp	/^  int m_elements;$/;"	m	class:Image
m_empty	interval.hpp	/^    bool m_empty;$/;"	m	class:IVector3D
m_empty	interval.hpp	/^    bool m_empty;$/;"	m	class:Interval
m_endpoint	ray.hpp	/^    Point3D m_endpoint;$/;"	m	class:Ray
m_epsilon	ray.hpp	/^    double m_epsilon;$/;"	m	class:Ray
m_eye	camera.hpp	/^    Point3D m_eye;$/;"	m	class:Camera
m_faces	mesh.hpp	/^    std::vector<Face> m_faces;$/;"	m	class:Mesh
m_filename	paintcanvas.hpp	/^    QString m_filename;$/;"	m	class:PaintCanvas
m_finite	packet.hpp	/^    bool m_finite;$/;"	m	class:Packet
m_firstActive	bih.cpp	/^        int m_firstActive;$/;"	m	struct:__anon3::Node	file:
m_firstRun	scene.hpp	/^    bool m_firstRun;$/;"	m	class:SceneNode
m_fov	camera.hpp	/^    double m_fov;$/;"	m	class:Camera
m_game	paintcanvas.hpp	/^    Game* m_game;$/;"	m	class:PaintCanvas
m_gameTimer	paintcanvas.hpp	/^    QTimer* m_gameTimer;$/;"	m	class:PaintCanvas
m_globalBBox	bih.hpp	/^    AABB m_globalBBox;$/;"	m	class:BIHTree
m_hasEndpoint	ray.hpp	/^    bool m_hasEndpoint;$/;"	m	class:Ray
m_hasGame	paintcanvas.hpp	/^    bool m_hasGame;$/;"	m	class:PaintCanvas
m_height	camera.hpp	/^    int m_height;$/;"	m	class:Camera
m_height	image.hpp	/^  int m_width, m_height;$/;"	m	class:Image
m_height	packet.hpp	/^    int m_height;$/;"	m	class:CameraPacket
m_i	packet.hpp	/^    int m_i;$/;"	m	class:CameraPacket
m_ibbox	bbox.hpp	/^    IVector3D m_ibbox;$/;"	m	class:AABB
m_id	scene.hpp	/^    int m_id;$/;"	m	class:SceneNode
m_img	packet.hpp	/^    QImage* m_img;$/;"	m	class:CameraPacket
m_img	paintcanvas.hpp	/^    QImage* m_img;$/;"	m	class:PaintCanvas
m_index	paintcanvas.hpp	/^    int m_index;$/;"	m	class:PaintCanvas
m_initCam	paintcanvas.hpp	/^    Camera* m_initCam;$/;"	m	class:PaintCanvas
m_innerPoint	mesh.hpp	/^    Point3D m_innerPoint;$/;"	m	class:Polygon
m_inv	primitive.hpp	/^    Matrix4x4 m_inv;$/;"	m	class:Primitive
m_inv	scene.hpp	/^    Matrix4x4 m_inv;$/;"	m	class:SceneNode
m_j	packet.hpp	/^    int m_j;$/;"	m	class:CameraPacket
m_joint_x	scene.hpp	/^    JointRange m_joint_x, m_joint_y;$/;"	m	class:JointNode
m_joint_y	scene.hpp	/^    JointRange m_joint_x, m_joint_y;$/;"	m	class:JointNode
m_k	paintcanvas.hpp	/^    int m_k;$/;"	m	class:PaintCanvas
m_kd	material.hpp	/^  Colour m_kd;$/;"	m	class:PhongMaterial
m_ks	material.hpp	/^  Colour m_ks;$/;"	m	class:PhongMaterial
m_length	packet.hpp	/^    double m_length;$/;"	m	class:Packet
m_length	ray.hpp	/^    double m_length;$/;"	m	class:Ray
m_lights	paintcanvas.hpp	/^    const std::list<Light*>* m_lights;$/;"	m	class:PaintCanvas
m_lights	tracer.hpp	/^    const std::list<Light*>* m_lights;$/;"	m	class:Tracer
m_material	intersection.hpp	/^    PhongMaterial* m_material;$/;"	m	class:Intersection
m_material	primitive.hpp	/^    PhongMaterial* m_material;$/;"	m	class:Primitive
m_material	scene.hpp	/^    Material* m_material;$/;"	m	class:GeometryNode
m_max	bbox.hpp	/^    Point3D m_max;$/;"	m	class:AABB
m_medium	material.hpp	/^  double m_medium;$/;"	m	class:PhongMaterial
m_menu_app	paintwindow.hpp	/^    QMenu* m_menu_app;$/;"	m	class:PaintWindow
m_min	bbox.hpp	/^    Point3D m_min;$/;"	m	class:AABB
m_modelBBox	primitive.hpp	/^    AABB m_modelBBox;$/;"	m	class:Primitive
m_mutex	paintcanvas.hpp	/^    pthread_mutex_t m_mutex;$/;"	m	class:PaintCanvas
m_name	scene.hpp	/^    std::string m_name;$/;"	m	class:SceneNode
m_node	bih.cpp	/^        BIHNode* m_node;$/;"	m	struct:__anon3::Node	file:
m_normal	intersection.hpp	/^    Vector3D m_normal;$/;"	m	class:Intersection
m_normal	mesh.hpp	/^    Vector3D m_normal;$/;"	m	class:Polygon
m_numPrimitives	bih.hpp	/^        int m_numPrimitives;$/;"	m	union:BIHNode::__anon2
m_numPrimitives	bih.hpp	/^    int m_numPrimitives;$/;"	m	class:BIHTree
m_num_parents	scene.hpp	/^    int m_num_parents;$/;"	m	class:SceneNode
m_origin	packet.hpp	/^    IVector3D m_origin;$/;"	m	class:Packet
m_origin	ray.hpp	/^    Point3D m_origin;$/;"	m	class:Ray
m_packets	paintcanvas.hpp	/^    std::vector<CameraPacket*>* m_packets;$/;"	m	class:PaintCanvas
m_param	intersection.hpp	/^    double m_param;$/;"	m	class:Intersection
m_pieceTypes	scene.hpp	/^    std::vector<Primitive*> m_pieceTypes;$/;"	m	class:TetrisNode
m_pieces	scene.hpp	/^    std::vector<Primitive*> m_pieces;$/;"	m	class:TetrisNode
m_piecesMoved	paintcanvas.hpp	/^    bool m_piecesMoved;$/;"	m	class:PaintCanvas
m_planes	bih.hpp	/^        double* m_planes;$/;"	m	union:BIHNode::__anon2
m_point	intersection.hpp	/^    Point3D m_point;$/;"	m	class:Intersection
m_pos	primitive.hpp	/^    Point3D m_pos;$/;"	m	class:NonhierBox
m_pos	primitive.hpp	/^    Point3D m_pos;$/;"	m	class:NonhierSphere
m_primitive	scene.hpp	/^    Primitive* m_primitive;$/;"	m	class:GeometryNode
m_primitive_pushed	scene.hpp	/^    bool m_primitive_pushed;$/;"	m	class:GeometryNode
m_primitives	bih.hpp	/^        Primitive** m_primitives;$/;"	m	union:BIHNode::__anon1
m_primitives	bih.hpp	/^    Primitive** m_primitives;$/;"	m	class:BIHTree
m_primitives	paintcanvas.hpp	/^    std::vector<Primitive*>* m_primitives;$/;"	m	class:PaintCanvas
m_primitives	tracer.hpp	/^    std::vector<Primitive*>* m_primitives;$/;"	m	class:Tracer
m_radius	primitive.hpp	/^    double m_radius;$/;"	m	class:NonhierSphere
m_rays	packet.hpp	/^    std::vector<Ray*>* m_rays;$/;"	m	class:Packet
m_refreshScreen	paintcanvas.hpp	/^    bool m_refreshScreen;$/;"	m	class:PaintCanvas
m_resizeTimer	paintcanvas.hpp	/^    QTimer* m_resizeTimer;$/;"	m	class:PaintCanvas
m_root	bih.hpp	/^    BIHNode* m_root;$/;"	m	class:BIHTree
m_root	paintcanvas.hpp	/^    SceneNode* m_root;$/;"	m	class:PaintCanvas
m_sampleWidth	packet.hpp	/^    int m_sampleWidth;$/;"	m	class:CameraPacket
m_screenToWorld	camera.hpp	/^    Matrix4x4 m_screenToWorld;$/;"	m	class:Camera
m_shininess	material.hpp	/^  double m_shininess;$/;"	m	class:PhongMaterial
m_size	primitive.hpp	/^    double m_size;$/;"	m	class:NonhierBox
m_threads	paintcanvas.hpp	/^    pthread_t m_threads[NUMTHREADS];$/;"	m	class:PaintCanvas
m_tracer	packet.hpp	/^    Tracer* m_tracer;$/;"	m	class:CameraPacket
m_tracer	paintcanvas.hpp	/^    Tracer* m_tracer;$/;"	m	class:PaintCanvas
m_trans	primitive.hpp	/^    Matrix4x4 m_trans;$/;"	m	class:Primitive
m_trans	scene.hpp	/^    Matrix4x4 m_trans;$/;"	m	class:SceneNode
m_transmitRatio	material.hpp	/^  double m_transmitRatio;$/;"	m	class:PhongMaterial
m_type	bih.hpp	/^    Type m_type;$/;"	m	class:BIHNode
m_up	camera.hpp	/^    Vector3D m_up;$/;"	m	class:Camera
m_updateTimer	paintcanvas.hpp	/^    QTimer* m_updateTimer;$/;"	m	class:PaintCanvas
m_verts	mesh.hpp	/^    std::vector<Point3D> m_verts;$/;"	m	class:Mesh
m_verts	mesh.hpp	/^    std::vector<Point3D> m_verts;$/;"	m	class:Polygon
m_view	camera.hpp	/^    Vector3D m_view;$/;"	m	class:Camera
m_width	camera.hpp	/^    int m_width;$/;"	m	class:Camera
m_width	image.hpp	/^  int m_width, m_height;$/;"	m	class:Image
m_width	packet.hpp	/^    int m_width;$/;"	m	class:CameraPacket
m_worldBBox	primitive.hpp	/^    AABB m_worldBBox;$/;"	m	class:Primitive
main	main.cpp	/^int main(int argc, char** argv)$/;"	f
margins_	game.hpp	/^  int margins_[4];$/;"	m	class:Piece
material	scene_lua.cpp	/^  Material* material;$/;"	m	struct:gr_material_ud	file:
max	algebra.cpp	/^Point3D Point3D::max(const Point3D& p1, const Point3D& p2) {$/;"	f	class:Point3D
max	scene.hpp	/^        double min, init, max;$/;"	m	struct:JointNode::JointRange
metaObject	moc_paintcanvas.cpp	/^const QMetaObject *PaintCanvas::metaObject() const$/;"	f	class:PaintCanvas
metaObject	moc_paintwindow.cpp	/^const QMetaObject *PaintWindow::metaObject() const$/;"	f	class:PaintWindow
min	algebra.cpp	/^Point3D Point3D::min(const Point3D& p1, const Point3D& p2) {$/;"	f	class:Point3D
min	scene.hpp	/^        double min, init, max;$/;"	m	struct:JointNode::JointRange
minimumSizeHint	paintcanvas.cpp	/^QSize PaintCanvas::minimumSizeHint() const {$/;"	f	class:PaintCanvas
moveLeft	game.cpp	/^bool Game::moveLeft()$/;"	f	class:Game
moveRight	game.cpp	/^bool Game::moveRight()$/;"	f	class:Game
node	scene_lua.cpp	/^  SceneNode* node;$/;"	m	struct:gr_node_ud	file:
normalize	algebra.cpp	/^double Vector3D::normalize()$/;"	f	class:Vector3D
operator ()	image.cpp	/^double Image::operator()(int x, int y, int i) const$/;"	f	class:Image
operator ()	image.cpp	/^double& Image::operator()(int x, int y, int i)$/;"	f	class:Image
operator ()	ray.hpp	/^    Point3D operator() (double t) const { return m_origin + t * m_direction; }$/;"	f	class:Ray
operator *	algebra.hpp	/^inline Colour operator *(const Colour& a, const Colour& b)$/;"	f
operator *	algebra.hpp	/^inline Colour operator *(double s, const Colour& a)$/;"	f
operator *	algebra.hpp	/^inline Matrix4x4 operator *(const Matrix4x4& a, const Matrix4x4& b)$/;"	f
operator *	algebra.hpp	/^inline Point3D operator *(const Matrix4x4& M, const Point3D& p)$/;"	f
operator *	algebra.hpp	/^inline Point3D operator *(double s, const Point3D& p)$/;"	f
operator *	algebra.hpp	/^inline Vector3D operator *(const Matrix4x4& M, const Vector3D& v)$/;"	f
operator *	algebra.hpp	/^inline Vector3D operator *(const Vector3D& v, double s)$/;"	f
operator *	algebra.hpp	/^inline Vector3D operator *(double s, const Vector3D& v)$/;"	f
operator *	interval.cpp	/^Interval operator*(const Interval& a, const Interval& b) {$/;"	f
operator *	interval.cpp	/^Interval operator*(const Interval& a, double val) {$/;"	f
operator *	interval.hpp	/^inline IVector3D operator *(const IVector3D& a, const IVector3D& b)$/;"	f
operator *	interval.hpp	/^inline IVector3D operator *(const IVector3D& v, const Interval& s)$/;"	f
operator *	interval.hpp	/^inline IVector3D operator *(const Interval& s, const IVector3D& v)$/;"	f
operator *	ray.hpp	/^inline Ray operator*(const Matrix4x4& mat, const Ray& ray) {$/;"	f
operator *=	algebra.cpp	/^Colour& Colour::operator *=(const Colour& other) {$/;"	f	class:Colour
operator +	algebra.hpp	/^inline Colour operator +(const Colour& a, const Colour& b)$/;"	f
operator +	algebra.hpp	/^inline Point3D operator +(const Point3D& a, const Point3D& b)$/;"	f
operator +	algebra.hpp	/^inline Point3D operator +(const Point3D& a, const Vector3D& b)$/;"	f
operator +	algebra.hpp	/^inline Vector3D operator +(const Vector3D& a, const Vector3D& b)$/;"	f
operator +	interval.hpp	/^inline IVector3D operator +(const IVector3D& a, const IVector3D& b)$/;"	f
operator +	interval.hpp	/^inline Interval operator+(const Interval& a, const Interval& b) {$/;"	f
operator +	interval.hpp	/^inline Interval operator+(const Interval& a, double val){$/;"	f
operator +=	algebra.cpp	/^Colour& Colour::operator +=(const Colour& other) {$/;"	f	class:Colour
operator -	algebra.hpp	/^inline Point3D operator -(const Point3D& a, const Vector3D& b)$/;"	f
operator -	algebra.hpp	/^inline Vector3D operator -(const Point3D& a, const Point3D& b)$/;"	f
operator -	algebra.hpp	/^inline Vector3D operator -(const Vector3D& a)$/;"	f
operator -	algebra.hpp	/^inline Vector3D operator -(const Vector3D& a, const Vector3D& b)$/;"	f
operator -	interval.hpp	/^inline IVector3D operator -(const IVector3D& a)$/;"	f
operator -	interval.hpp	/^inline IVector3D operator -(const IVector3D& a, const IVector3D& b)$/;"	f
operator -	interval.hpp	/^inline Interval operator-(const Interval& a) {$/;"	f
operator -	interval.hpp	/^inline Interval operator-(const Interval& a, const Interval& b) {$/;"	f
operator -	interval.hpp	/^inline Interval operator-(const Interval& a, double val){$/;"	f
operator <<	algebra.hpp	/^inline std::ostream& operator <<(std::ostream& os, const Colour& c)$/;"	f
operator <<	algebra.hpp	/^inline std::ostream& operator <<(std::ostream& os, const Matrix4x4& M)$/;"	f
operator <<	algebra.hpp	/^inline std::ostream& operator <<(std::ostream& os, const Point2D& p)$/;"	f
operator <<	algebra.hpp	/^inline std::ostream& operator <<(std::ostream& os, const Point3D& p)$/;"	f
operator <<	algebra.hpp	/^inline std::ostream& operator <<(std::ostream& os, const Vector3D& v)$/;"	f
operator <<	intersection.cpp	/^std::ostream& operator<<(std::ostream& out, const Intersection& isect)$/;"	f
operator <<	interval.hpp	/^inline std::ostream& operator <<(std::ostream& os, const IVector3D& iv)$/;"	f
operator <<	interval.hpp	/^inline std::ostream& operator <<(std::ostream& os, const Interval& I)$/;"	f
operator <<	light.cpp	/^std::ostream& operator<<(std::ostream& out, const Light& l)$/;"	f
operator <<	mesh.cpp	/^std::ostream& operator<<(std::ostream& out, const Mesh& mesh)$/;"	f
operator =	algebra.hpp	/^  Colour& operator =(const Colour& other)$/;"	f	class:Colour
operator =	algebra.hpp	/^  Matrix4x4& operator=(const Matrix4x4& other)$/;"	f	class:Matrix4x4
operator =	algebra.hpp	/^  Point2D& operator =(const Point2D& other)$/;"	f	class:Point2D
operator =	algebra.hpp	/^  Point3D& operator =(const Point3D& other)$/;"	f	class:Point3D
operator =	algebra.hpp	/^  Vector3D& operator =(const Vector3D& other)$/;"	f	class:Vector3D
operator =	algebra.hpp	/^  Vector4D& operator =(const Vector4D& other)$/;"	f	class:Vector4D
operator =	bbox.cpp	/^AABB& AABB::operator=(const AABB& other) {$/;"	f	class:AABB
operator =	camera.cpp	/^Camera& Camera::operator=(const Camera& other) {$/;"	f	class:Camera
operator =	game.cpp	/^Piece& Piece::operator =(const Piece& other)$/;"	f	class:Piece
operator =	image.cpp	/^Image& Image::operator=(const Image& other)$/;"	f	class:Image
operator =	intersection.cpp	/^Intersection& Intersection::operator=(const Intersection& other) {$/;"	f	class:Intersection
operator =	interval.cpp	/^IVector3D& IVector3D::operator=(const IVector3D& other) {$/;"	f	class:IVector3D
operator =	interval.cpp	/^Interval& Interval::operator=(const Interval& other) {$/;"	f	class:Interval
operator =	mesh.cpp	/^Mesh& Mesh::operator=(const Mesh& other) {$/;"	f	class:Mesh
operator =	mesh.cpp	/^Polygon& Polygon::operator=(const Polygon& other) {$/;"	f	class:Polygon
operator =	mesh.cpp	/^Triangle& Triangle::operator=(const Triangle& other) {$/;"	f	class:Triangle
operator =	packet.cpp	/^CameraPacket& CameraPacket::operator=(const CameraPacket& other) {$/;"	f	class:CameraPacket
operator =	packet.cpp	/^Packet& Packet::operator=(const Packet& other) {$/;"	f	class:Packet
operator =	primitive.cpp	/^Cube& Cube::operator=(const Cube& other) {$/;"	f	class:Cube
operator =	primitive.cpp	/^NonhierBox& NonhierBox::operator=(const NonhierBox& other) {$/;"	f	class:NonhierBox
operator =	primitive.cpp	/^NonhierSphere& NonhierSphere::operator=(const NonhierSphere& other) {$/;"	f	class:NonhierSphere
operator =	primitive.cpp	/^Primitive& Primitive::operator=(const Primitive& other) {$/;"	f	class:Primitive
operator =	primitive.cpp	/^Sphere& Sphere::operator=(const Sphere& other) {$/;"	f	class:Sphere
operator =	ray.cpp	/^Ray& Ray::operator=(const Ray& other) {$/;"	f	class:Ray
operator []	algebra.hpp	/^  Vector4D operator[](size_t row) const$/;"	f	class:Matrix4x4
operator []	algebra.hpp	/^  double *operator[](size_t row) $/;"	f	class:Matrix4x4
operator []	algebra.hpp	/^  double operator[](size_t idx) const $/;"	f	class:Point2D
operator []	algebra.hpp	/^  double operator[](size_t idx) const $/;"	f	class:Point3D
operator []	algebra.hpp	/^  double operator[](size_t idx) const $/;"	f	class:Vector3D
operator []	algebra.hpp	/^  double operator[](size_t idx) const $/;"	f	class:Vector4D
operator []	algebra.hpp	/^  double& operator[](size_t idx) $/;"	f	class:Point2D
operator []	algebra.hpp	/^  double& operator[](size_t idx) $/;"	f	class:Point3D
operator []	algebra.hpp	/^  double& operator[](size_t idx) $/;"	f	class:Vector3D
operator []	algebra.hpp	/^  double& operator[](size_t idx) $/;"	f	class:Vector4D
operator []	interval.hpp	/^    Interval operator[](size_t idx) const $/;"	f	class:IVector3D
operator []	interval.hpp	/^    Interval& operator[](size_t idx) $/;"	f	class:IVector3D
operator []	interval.hpp	/^    double operator[](size_t idx) const $/;"	f	class:Interval
operator []	interval.hpp	/^    double& operator[](size_t idx) $/;"	f	class:Interval
packetTest	bbox.cpp	/^int AABB::packetTest(Packet& packet, int firstActive) {$/;"	f	class:AABB
paintEvent	paintcanvas.cpp	/^void PaintCanvas::paintEvent(QPaintEvent* event) {$/;"	f	class:PaintCanvas
piece_	game.hpp	/^  Piece piece_;$/;"	m	class:Game
placePiece	game.cpp	/^void Game::placePiece(const Piece& p, int x, int y)$/;"	f	class:Game
position	light.hpp	/^  Point3D position;$/;"	m	struct:Light
px_	game.hpp	/^  int px_;$/;"	m	class:Game
py_	game.hpp	/^  int py_;$/;"	m	class:Game
qt_meta_data_PaintCanvas	moc_paintcanvas.cpp	/^static const uint qt_meta_data_PaintCanvas[] = {$/;"	v	file:
qt_meta_data_PaintWindow	moc_paintwindow.cpp	/^static const uint qt_meta_data_PaintWindow[] = {$/;"	v	file:
qt_meta_stringdata_PaintCanvas	moc_paintcanvas.cpp	/^static const qt_meta_stringdata_PaintCanvas_t qt_meta_stringdata_PaintCanvas = {$/;"	v	file:
qt_meta_stringdata_PaintCanvas_t	moc_paintcanvas.cpp	/^struct qt_meta_stringdata_PaintCanvas_t {$/;"	s	file:
qt_meta_stringdata_PaintWindow	moc_paintwindow.cpp	/^static const qt_meta_stringdata_PaintWindow_t qt_meta_stringdata_PaintWindow = {$/;"	v	file:
qt_meta_stringdata_PaintWindow_t	moc_paintwindow.cpp	/^struct qt_meta_stringdata_PaintWindow_t {$/;"	s	file:
qt_metacall	moc_paintcanvas.cpp	/^int PaintCanvas::qt_metacall(QMetaObject::Call _c, int _id, void **_a)$/;"	f	class:PaintCanvas
qt_metacall	moc_paintwindow.cpp	/^int PaintWindow::qt_metacall(QMetaObject::Call _c, int _id, void **_a)$/;"	f	class:PaintWindow
qt_metacast	moc_paintcanvas.cpp	/^void *PaintCanvas::qt_metacast(const char *_clname)$/;"	f	class:PaintCanvas
qt_metacast	moc_paintwindow.cpp	/^void *PaintWindow::qt_metacast(const char *_clname)$/;"	f	class:PaintWindow
qt_static_metacall	moc_paintcanvas.cpp	/^void PaintCanvas::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)$/;"	f	class:PaintCanvas
qt_static_metacall	moc_paintwindow.cpp	/^void PaintWindow::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)$/;"	f	class:PaintWindow
quadraticRoots	polyroots.cpp	/^size_t quadraticRoots( double A, double B, double C, double roots[2] )$/;"	f
quarticRoots	polyroots.cpp	/^size_t quarticRoots( $/;"	f
r_	algebra.hpp	/^  double r_;$/;"	m	class:Colour
reciprocal	interval.cpp	/^IVector3D IVector3D::reciprocal() {$/;"	f	class:IVector3D
reciprocal	interval.cpp	/^Interval Interval::reciprocal() {$/;"	f	class:Interval
refresh	paintcanvas.cpp	/^void PaintCanvas::refresh() {$/;"	f	class:PaintCanvas
removePiece	game.cpp	/^void Game::removePiece(const Piece& p, int x, int y) $/;"	f	class:Game
removeRow	game.cpp	/^void Game::removeRow(int y)$/;"	f	class:Game
reset	game.cpp	/^void Game::reset()$/;"	f	class:Game
resizeAction	paintcanvas.cpp	/^void PaintCanvas::resizeAction() {$/;"	f	class:PaintCanvas
resizeCanvas	paintwindow.cpp	/^void PaintWindow::resizeCanvas() {$/;"	f	class:PaintWindow
resizeEvent	paintcanvas.cpp	/^void PaintCanvas::resizeEvent(QResizeEvent* event) {$/;"	f	class:PaintCanvas
rotate	scene.cpp	/^void SceneNode::rotate(char axis, double angle)$/;"	f	class:SceneNode
rotateCCW	game.cpp	/^Piece Piece::rotateCCW() const$/;"	f	class:Piece
rotateCCW	game.cpp	/^bool Game::rotateCCW() $/;"	f	class:Game
rotateCW	game.cpp	/^Piece Piece::rotateCW() const$/;"	f	class:Piece
rotateCW	game.cpp	/^bool Game::rotateCW() $/;"	f	class:Game
run_lua	scene_lua.cpp	/^bool run_lua(const std::string& filename)$/;"	f
saveImage	paintcanvas.cpp	/^void PaintCanvas::saveImage() {$/;"	f	class:PaintCanvas
savePng	image.cpp	/^bool Image::savePng(const std::string& filename)$/;"	f	class:Image
scale	scene.cpp	/^void SceneNode::scale(const Vector3D& amount)$/;"	f	class:SceneNode
setBBox	primitive.cpp	/^void Primitive::setBBox(const Point3D& min, const Point3D& max) {$/;"	f	class:Primitive
setMaterial	primitive.hpp	/^    void setMaterial(PhongMaterial* material) { m_material = material; }$/;"	f	class:Primitive
setRays	packet.cpp	/^void Packet::setRays(vector<Ray*>* rays) {$/;"	f	class:Packet
setTransform	primitive.cpp	/^void Primitive::setTransform(const Matrix4x4& trans, const Matrix4x4& inv) {$/;"	f	class:Primitive
set_intersection	interval.cpp	/^Interval Interval::set_intersection(const Interval& a, const Interval& b) {$/;"	f	class:Interval
set_joint_x	scene.cpp	/^void JointNode::set_joint_x(double min, double init, double max)$/;"	f	class:JointNode
set_joint_y	scene.cpp	/^void JointNode::set_joint_y(double min, double init, double max)$/;"	f	class:JointNode
set_material	scene.hpp	/^    void set_material(Material* material)$/;"	f	class:GeometryNode
set_union	interval.cpp	/^Interval Interval::set_union(const Interval& a, const Interval& b) {$/;"	f	class:Interval
sink_lookup	polyroots.cpp	/^static double sink_lookup(double t)$/;"	f	file:
sizeHint	paintcanvas.cpp	/^QSize PaintCanvas::sizeHint() const {$/;"	f	class:PaintCanvas
staticMetaObject	moc_paintcanvas.cpp	/^const QMetaObject PaintCanvas::staticMetaObject = {$/;"	m	class:PaintCanvas	file:
staticMetaObject	moc_paintwindow.cpp	/^const QMetaObject PaintWindow::staticMetaObject = {$/;"	m	class:PaintWindow	file:
stopped_	game.hpp	/^  bool stopped_;$/;"	m	class:Game
stringdata	moc_paintcanvas.cpp	/^    char stringdata[40];$/;"	m	struct:qt_meta_stringdata_PaintCanvas_t	file:
stringdata	moc_paintwindow.cpp	/^    char stringdata[13];$/;"	m	struct:qt_meta_stringdata_PaintWindow_t	file:
submultrow	algebra.cpp	/^static void submultrow(Matrix4x4& a, size_t dest, size_t src, double fac)$/;"	f	file:
swaprows	algebra.cpp	/^static void swaprows(Matrix4x4& a, size_t r1, size_t r2)$/;"	f	file:
thread_bootstrap	paintcanvas.cpp	/^void* PaintCanvas::thread_bootstrap(void* canvas) {$/;"	f	class:PaintCanvas
tick	game.cpp	/^int Game::tick()$/;"	f	class:Game
tick	paintcanvas.cpp	/^void PaintCanvas::tick() {$/;"	f	class:PaintCanvas
toInt	algebra.cpp	/^uint Colour::toInt() const {$/;"	f	class:Colour
trace	packet.cpp	/^void CameraPacket::trace() {$/;"	f	class:CameraPacket
tracePacket	tracer.cpp	/^void Tracer::tracePacket(Packet& packet, ColourVector* colours, vector<bool>& v_hit, int depth) {$/;"	f	class:Tracer
tracePixel	packet.cpp	/^void CameraPacket::tracePixel(int i, int j) {$/;"	f	class:CameraPacket
tracePixel	packet.cpp	/^void CameraPacket::tracePixel(int i, int j, ColourVector& colours, vector<bool>& v_hit) {$/;"	f	class:CameraPacket
traceRay	tracer.cpp	/^bool Tracer::traceRay(Ray& ray, Colour& colour, int depth) {$/;"	f	class:Tracer
transNorm	algebra.hpp	/^inline Vector3D transNorm(const Matrix4x4& M, const Vector3D& n)$/;"	f
translate	scene.cpp	/^void SceneNode::translate(const Vector3D& amount)$/;"	f	class:SceneNode
transpose	algebra.hpp	/^  Matrix4x4 transpose() const$/;"	f	class:Matrix4x4
traversalOrder	bih.cpp	/^int BIHNode::traversalOrder(const Ray& ray) {$/;"	f	class:BIHNode
unpackPrimitives	tracer.cpp	/^static Primitive** unpackPrimitives(vector<Primitive*>* primitives) {$/;"	f	file:
updateDimensions	camera.cpp	/^void Camera::updateDimensions(int width, int height) {$/;"	f	class:Camera
updateIntervals	packet.cpp	/^void CameraPacket::updateIntervals() {$/;"	f	class:CameraPacket
updateIntervals	packet.cpp	/^void Packet::updateIntervals() {$/;"	f	class:Packet
updatePrimitives	tracer.cpp	/^void Tracer::updatePrimitives(vector<Primitive*>* primitives) {$/;"	f	class:Tracer
updateScreenToWorld	camera.cpp	/^void Camera::updateScreenToWorld() {$/;"	f	class:Camera
v_	algebra.hpp	/^  double v_[16];$/;"	m	class:Matrix4x4
v_	algebra.hpp	/^  double v_[2];$/;"	m	class:Point2D
v_	algebra.hpp	/^  double v_[3];$/;"	m	class:Point3D
v_	algebra.hpp	/^  double v_[3];$/;"	m	class:Vector3D
v_	algebra.hpp	/^  double v_[4];$/;"	m	class:Vector4D
v_	interval.hpp	/^    Interval v_[3];$/;"	m	class:IVector3D
v_	interval.hpp	/^    double v_[2];$/;"	m	class:Interval
width	image.cpp	/^int Image::width() const$/;"	f	class:Image
x_axis	bih.hpp	/^        x_axis,$/;"	e	enum:BIHNode::Type
y_axis	bih.hpp	/^        y_axis,$/;"	e	enum:BIHNode::Type
z_axis	bih.hpp	/^        z_axis,$/;"	e	enum:BIHNode::Type
~AABB	bbox.cpp	/^AABB::~AABB() {}$/;"	f	class:AABB
~BIHNode	bih.cpp	/^BIHNode::~BIHNode() {$/;"	f	class:BIHNode
~BIHTree	bih.cpp	/^BIHTree::~BIHTree() {$/;"	f	class:BIHTree
~CameraPacket	packet.cpp	/^CameraPacket::~CameraPacket() {}$/;"	f	class:CameraPacket
~Cube	primitive.cpp	/^Cube::~Cube()$/;"	f	class:Cube
~Game	game.cpp	/^Game::~Game()$/;"	f	class:Game
~GeometryNode	scene.cpp	/^GeometryNode::~GeometryNode()$/;"	f	class:GeometryNode
~Image	image.cpp	/^Image::~Image()$/;"	f	class:Image
~Intersection	intersection.cpp	/^Intersection::~Intersection() {}$/;"	f	class:Intersection
~Interval	interval.cpp	/^Interval::~Interval() {}$/;"	f	class:Interval
~JointNode	scene.cpp	/^JointNode::~JointNode()$/;"	f	class:JointNode
~Material	material.cpp	/^Material::~Material()$/;"	f	class:Material
~NonhierBox	primitive.cpp	/^NonhierBox::~NonhierBox()$/;"	f	class:NonhierBox
~NonhierSphere	primitive.cpp	/^NonhierSphere::~NonhierSphere()$/;"	f	class:NonhierSphere
~Packet	packet.cpp	/^Packet::~Packet() {$/;"	f	class:Packet
~PaintCanvas	paintcanvas.cpp	/^PaintCanvas::~PaintCanvas() {$/;"	f	class:PaintCanvas
~PaintWindow	paintwindow.hpp	/^    virtual ~PaintWindow() {}$/;"	f	class:PaintWindow
~PhongMaterial	material.cpp	/^PhongMaterial::~PhongMaterial()$/;"	f	class:PhongMaterial
~Primitive	primitive.cpp	/^Primitive::~Primitive()$/;"	f	class:Primitive
~Ray	ray.hpp	/^    ~Ray() {}$/;"	f	class:Ray
~SceneNode	scene.cpp	/^SceneNode::~SceneNode()$/;"	f	class:SceneNode
~Sphere	primitive.cpp	/^Sphere::~Sphere()$/;"	f	class:Sphere
~TetrisNode	scene.cpp	/^TetrisNode::~TetrisNode() $/;"	f	class:TetrisNode
